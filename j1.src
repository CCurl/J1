// ( Base words implemented in assembler        JCB 13:10 08/24/10)

: noop      T                       alu ; MACRO
: +         T+N                 d-1 alu ; MACRO
: xor       T^N                 d-1 alu ; MACRO
: and       T&N                 d-1 alu ; MACRO
: or        T|N                 d-1 alu ; MACRO
: invert    ~T                      alu ; MACRO
: =         N==T                d-1 alu ; MACRO
: <         N<T                 d-1 alu ; MACRO
: u<        Nu<T                d-1 alu ; MACRO
: swap      N     T->N              alu ; MACRO
: dup       T     T->N          d+1 alu ; MACRO
: drop      N                   d-1 alu ; MACRO
: over      N     T->N          d+1 alu ; MACRO
: nip       T                   d-1 alu ; MACRO
// : >r        N     T->R      r+1 d-1 alu ; MACRO
// : r>        rT    T->N      r-1 d+1 alu ; MACRO
// : r@        rT    T->N          d+1 alu ; MACRO
: @         [T]                     alu ; MACRO
: !         T     N->[T]        d-1 alu
            N                   d-1 alu ;
: depth     dsp   T->N          d+1 alu ; MACRO
: lshift    N<<T                d-1 alu ; MACRO
: rshift    N>>T                d-1 alu ; MACRO
: 1-        T-1                     alu ; MACRO
: 2r>       rT    T->N      r-1 d+1 alu
            rT    T->N      r-1 d+1 alu
            N     T->N              alu ;
: 2>r       N     T->N              alu
            N     T->R      r+1 d-1 alu
            N     T->R      r+1 d-1 alu ;
: 2r@       rT    T->N      r-1 d+1 alu
            rT    T->N      r-1 d+1 alu
            N     T->N          d+1 alu
            N     T->N          d+1 alu
            N     T->R      r+1 d-1 alu
            N     T->R      r+1 d-1 alu
            N     T->N              alu ;
: unloop
            T               r-1     alu
            T               r-1     alu ;
\ : exit      return ;

\ Elided words
: dup@      [T]   T->N          d+1 alu ; MACRO
: dup>r     T     T->R          r+1 alu ;
: 2dupxor   T^N   T->N          d+1 alu ; MACRO
: 2dup=     N==T  T->N          d+1 alu ; MACRO
: !nip      T     N->[T]        d-1 alu ; MACRO
: 2dup!     T     N->[T]            alu ; MACRO

\ Words used to implement pick
: up1       T                   d+1 alu ; MACRO
: down1     T                   d-1 alu ; MACRO
: copy      N                       alu ; MACRO
: emit $4001 ! ;
: OK  'O' emit 'K' emit ;       // expect OK



// ****************************
// TESTS
// ****************************

: . $4002 ! ;
: emit $4001 ! ;
: cr #13 emit #10 emit ; : bl $20 emit ; 
: t cr . bl ;
: dup-test     1 t 36 dup . . ;              // expect 36 36
: nip-test     2 t 11 22 34 nip . . ;        // expect 34 11
: swap-test    3 t 11 22 swap . . ;          // expect 11 22
: drop-test    4 t 11 22 35 drop . . ;       // expect 22 11
: over-test    5 t 83 19 over . . . ;        // expect 83 19 83
: 0000-test    6 t 0 . ;                     // expect 0
: dot-test     7 t 12345 . ;                 // expect 12345
: r-test       8 t 71 123 >r . 654 . r> . ;  // expect 71 654 123
: r@-test      9 t 81 >r 234 . r@ . r> . ;   // expect 234 81 81
: add-test    10 t 1 2 3 4 + + + . ;         // expect 10
: depth-test  11 t 7 8 9 depth . . . . ;     // expect 3 9 8 7
: 1--test     12 t 3345 1- . ;               // expect 3344
: main dup-test nip-test swap-test 
    drop-test over-test 0000-test
    dot-test r-test r@-test add-test
    depth-test 1--test cr OK ;
// : newMain depth-test ;